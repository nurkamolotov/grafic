#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Zirve ‚Äî S/R (0.70% + 1. mum kapalƒ± + 2. mum CANLI) + Vol & Corr + HTF Trend GATE (5h)
--------------------------------------------------------------------------------------
‚Ä¢ Sinyal mantƒ±ƒüƒ±:
   1) Pivot (swing)
   2) Pivot sonrasƒ± i+1..i+2/3 aralƒ±ƒüƒ±nda extremumla ‚â• %0.70 ters hareket
   3) i+1 barƒ± ters y√∂ne KAPANI≈û (zorunlu)
   4) i+2 barƒ± CANLI (zorunlu) ve ters y√∂n√º s√ºrd√ºrmeli
   5) Sinyal anƒ±: last - i == 2  (tam 2. mum canlƒ±)

‚Ä¢ Filtreler:
   - Volatilite skoru (0..1)  ‚Üí GUI ‚ÄúVol ‚â•‚Äù (default 0.50)
   - BTC korelasyonu |corr|   ‚Üí GUI ‚Äú|Corr| ‚â§‚Äù (default 0.70)
   - Trend Mode (GUI):
        ‚Ä¢ 5h Structure (HH/HL): Son 5 saat 1H mumlarda HH&HL ‚Üí UP, LH&LL ‚Üí DOWN, aksi ‚Üí SIDE
        ‚Ä¢ 24h Change %        : 24√ó1h kapanƒ±≈ü deƒüi≈üimine g√∂re UP/DOWN/SIDE

‚Ä¢ Telegram opsiyonel.
"""

import os, sys, time, threading, warnings, subprocess, webbrowser
warnings.filterwarnings("ignore")

import ccxt
import numpy as np
import pandas as pd
import PySimpleGUI as sg

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from ccxt.base.errors import DDoSProtection, RateLimitExceeded, NetworkError
import requests

# =============== (Opsiyonel) Telegram ===============
TG_TOKEN   = os.getenv("TG_TOKEN", "8080474574:AAGDLzJzWgU15Fr_SSeuRQPSaon1Fu4gHjc")
TG_CHAT_ID = os.getenv("TG_CHAT_ID", "1449828433")

def send_telegram_alert(text: str):
    try:
        requests.post(
            f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
            data={"chat_id": TG_CHAT_ID, "text": text},
            timeout=6
        )
    except Exception:
        pass

# ====================== Helpers ======================

def ensure_dir(p): os.makedirs(p, exist_ok=True)

def open_path(path: str):
    try:
        if sys.platform.startswith("win"): os.startfile(path)
        elif sys.platform == "darwin": subprocess.Popen(["open", path])
        else: subprocess.Popen(["xdg-open", path])
    except Exception:
        pass

def bar_count_from_hours(tf: str, hours: int) -> int:
    m = {"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":240}.get(tf,5)
    return max(1, int(hours*60/m))

def _get(v, key, default):
    try: return v.get(key, default)
    except: return default

def _parse_int(v, key, default):
    s = str(_get(v, key, default)).strip()
    if s == "": return int(default)
    try: return int(s)
    except:
        try: return int(float(s.replace(",", ".")))
        except: return int(default)

def _parse_float(v, key, default):
    s = str(_get(v, key, default)).strip()
    if s == "": return float(default)
    try: return float(s.replace(",", "."))
    except: return float(default)

# ====================== CCXT / Binance ======================

def load_exchange():
    return ccxt.binance({"enableRateLimit": True, "options": {"defaultType": "future"}})

def fetch_ohlcv_with_retry(ex, symbol, tf, limit, tries=5):
    delay = 0.5
    for _ in range(tries):
        try:
            return ex.fetch_ohlcv(symbol, timeframe=tf, limit=limit)
        except (RateLimitExceeded, DDoSProtection, NetworkError):
            time.sleep(delay); delay = min(delay*2, 8.0)
    return ex.fetch_ohlcv(symbol, timeframe=tf, limit=limit)

def list_usdtm_symbols(ex, topN=500):
    mk = ex.load_markets()
    blacklist = {"BTCST/USDT:USDT", "BTCDOM/USDT:USDT", "DEFIUSDT/USDT:USDT"}
    syms = [
        sym for sym, m in mk.items()
        if m.get("linear") and m.get("contract") and sym.endswith(":USDT")
        and sym not in blacklist and m.get("active", True)
    ]
    return sorted(syms)[:topN]

def to_df(ohlcv):
    df = pd.DataFrame(ohlcv, columns=["time","open","high","low","close","volume"])
    df["time"] = pd.to_datetime(df["time"], unit="ms")
    df.set_index("time", inplace=True)
    return df

# ====================== Vol & Corr ======================

BTC_CACHE = {}
def get_btc_df_cached(ex, tf, limit, drop_last=True, source="perp"):
    key=(tf,limit,source)
    if key in BTC_CACHE: return BTC_CACHE[key]
    btc = "BTC/USDT:USDT" if source=="perp" else "BTC/USDT"
    df = to_df(fetch_ohlcv_with_retry(ex, btc, tf, limit))
    if drop_last and len(df)>0: df=df.iloc[:-1]
    BTC_CACHE[key]=df
    return df

def normalize_vol_0_1(vol_raw: float, soft_cap: float = 0.012):
    # 0..1 normalize (yakla≈üƒ±k %1.2 g√ºnl√ºk std √∂l√ßeƒüi varsayƒ±mƒ±)
    return float(np.clip(vol_raw / soft_cap, 0.0, 1.0))

def compute_vol_score(df: pd.DataFrame, vol_bars: int) -> float:
    if len(df) < vol_bars+2: return 0.0
    r=df["close"].pct_change()
    return normalize_vol_0_1(float(r.tail(vol_bars).std()))

def compute_corr_with_btc(df_sym, btc_df, corr_bars: int) -> float:
    df = pd.merge(df_sym[["close"]].reset_index(),
                  btc_df[["close"]].reset_index().rename(columns={"close":"close_btc"}),
                  on="time", how="inner").set_index("time")
    if len(df)<corr_bars+5: return 0.0
    sr=np.log(df["close"]).diff(); br=np.log(df["close_btc"]).diff()
    c=float(pd.concat([sr.tail(corr_bars), br.tail(corr_bars)], axis=1).corr().iloc[0,1])
    return 0.0 if np.isnan(c) else c

# ====================== Pivot (Swing) ======================

def is_swing_high(df,i,left,right):
    lo=max(0,i-left); hi=min(len(df),i+right+1)
    return df["high"].iloc[i] == df["high"].iloc[lo:hi].max()

def is_swing_low(df,i,left,right):
    lo=max(0,i-left); hi=min(len(df),i+right+1)
    return df["low"].iloc[i] == df["low"].iloc[lo:hi].min()

# === Momentum (0.70% + 1. mum kapalƒ± + 2. mum CANLI) ===
def momentum_reversal_ok_live2(df: pd.DataFrame, i: int, direction: str, min_move: float = 0.007) -> bool:
    last = len(df) - 1
    if i + 1 > last - 1:  # 1. mum kapanmƒ±≈ü olmalƒ±
        return False
    if last - i != 2:     # tam an: 2. mum canlƒ±
        return False
    end_idx = min(i + 2, last)

    if direction == "RES":  # tepeden d√º≈ü√º≈ü
        level = float(df["high"].iloc[i])
        min_low = float(df["low"].iloc[i+1:end_idx+1].min())
        move = (level - min_low) / max(1e-9, level)
        if move < min_move:
            return False
        if not (df["close"].iloc[i+1] < df["close"].iloc[i]):
            return False
        return df["close"].iloc[i+2] < df["close"].iloc[i+1]
    else:  # SUP ‚Äî dipten y√ºkseli≈ü
        level = float(df["low"].iloc[i])
        max_high = float(df["high"].iloc[i+1:end_idx+1].max())
        move = (max_high - level) / max(1e-9, level)
        if move < min_move:
            return False
        if not (df["close"].iloc[i+1] > df["close"].iloc[i]):
            return False
        return df["close"].iloc[i+2] > df["close"].iloc[i+1]

# ====================== Seviye Tespiti (yalnƒ±zca 2. mum canlƒ±) ======================

def cluster_levels(levels, tol_pct=0.5):
    if not levels: return []
    levels=sorted(levels,key=lambda x:x["price"])
    out=[]; cur=None
    for lv in levels:
        if cur is None:
            cur={**lv,"members":[lv]}
        elif abs(lv["price"]-cur["price"])/max(1e-9,cur["price"])<=tol_pct/100.0:
            cur["price"]=(cur["price"]*len(cur["members"])+lv["price"])/(len(cur["members"])+1)
            cur["members"].append(lv)
        else:
            out.append(dict(price=float(cur["price"]), side=cur["side"], index=max(m["index"] for m in cur["members"])))
            cur={**lv,"members":[lv]}
    if cur:
        out.append(dict(price=float(cur["price"]), side=cur["side"], index=max(m["index"] for m in cur["members"])) )
    return out

def detect_levels_minimal(df, tf="5m", swing_period=20, tol_pct=0.5, ttl_h=6):
    """
    Sinyali SADECE ≈üu anda √ºretir:
      ‚Ä¢ i = last - 2  ‚Üí 1. mum kapalƒ±, 2. mum CANLI (zorunlu)
    """
    L=[]; left=right=swing_period//2
    last = len(df)-1

    i = last - 2
    if i < left or i < 0:
        return []

    if is_swing_high(df, i, left, right) and momentum_reversal_ok_live2(df, i, "RES"):
        L.append(dict(price=float(df["high"].iloc[i]), side="RES", index=i))
    if is_swing_low(df, i, left, right) and momentum_reversal_ok_live2(df, i, "SUP"):
        L.append(dict(price=float(df["low"].iloc[i]), side="SUP", index=i))

    L = cluster_levels(L, tol_pct=tol_pct)
    bars_ttl = bar_count_from_hours(tf, ttl_h)
    return [lv for lv in L if (last - lv["index"]) <= bars_ttl]

# ====================== Trend (HTF gate: 5h Structure) ======================

def _mark_pivots_1h(fr: pd.DataFrame, left: int = 2, right: int = 2):
    highs = fr['high'].values
    lows  = fr['low'].values
    n = len(fr)
    pivH = np.zeros(n, dtype=bool)
    pivL = np.zeros(n, dtype=bool)
    for i in range(left, n-right):
        h = highs[i]; l = lows[i]
        if np.all(h >= highs[i-left:i]) and np.all(h >= highs[i+1:i+1+right]):
            pivH[i] = True
        if np.all(l <= lows[i-left:i]) and np.all(l <= lows[i+1:i+1+right]):
            pivL[i] = True
    out = fr.copy()
    out['pivH'] = pivH
    out['pivL'] = pivL
    return out

def htf_trend_struct(df_1h: pd.DataFrame, lookback_hours: int = 5, left: int = 1, right: int = 1, min_swing_pct: float = 0.001) -> str:
    """
    1H veride, son N saat yapƒ±sal salƒ±nƒ±mlara bakarak trend:
      - HH & HL ‚Üí UP
      - LH & LL ‚Üí DOWN
      - aksi ‚Üí SIDE
    """
    if len(df_1h) < (left + right + 5):
        return "SIDE"
    fr = _mark_pivots_1h(df_1h, left=left, right=right)

    end_ts = fr.index[-1]
    start_ts = end_ts - pd.Timedelta(hours=lookback_hours)
    window = fr.loc[fr.index >= start_ts]

    pts = []
    for ts, row in window.iterrows():
        if row.get('pivH', False):
            pts.append((ts, 'H', float(row['high'])))
        if row.get('pivL', False):
            pts.append((ts, 'L', float(row['low'])))
    if not pts:
        return "SIDE"
    pts.sort(key=lambda x: x[0])

    # alternans + min swing
    alt=[]
    for p in pts:
        if not alt:
            alt.append(p)
        else:
            if p[1] == alt[-1][1]:
                prev_price = alt[-1][2]
                if abs(p[2]-prev_price)/max(1e-9,prev_price) >= min_swing_pct:
                    alt[-1] = p
            else:
                alt.append(p)

    swings = alt[-4:]  # son 4 nokta
    highs = [(ts, px) for ts, t, px in swings if t=='H']
    lows  = [(ts, px) for ts, t, px in swings if t=='L']
    if len(highs) >= 2 and len(lows) >= 2:
        _, last_H  = highs[-1]; _, prev_H  = highs[-2]
        _, last_L  = lows[-1];  _, prev_L  = lows[-2]
        is_HH = last_H > prev_H
        is_HL = last_L > prev_L
        is_LH = last_H < prev_H
        is_LL = last_L < prev_L
        if is_HH and is_HL:  return "UP"
        if is_LH and is_LL:  return "DOWN"
    return "SIDE"

def trend_from_24h(ex, symbol):
    """Son 24 saatlik (24√ó1h) kapanƒ±≈üa g√∂re trend: UP/DOWN/SIDE"""
    try:
        df = to_df(fetch_ohlcv_with_retry(ex, symbol, "1h", 26))
        if len(df) < 25:
            return "SIDE"
        c_now = float(df["close"].iloc[-1])
        c_prev = float(df["close"].iloc[-25])
        pct = (c_now - c_prev) / max(1e-12, c_prev)
        if pct > 0.01:      return "UP"
        elif pct < -0.01:   return "DOWN"
        else:               return "SIDE"
    except:
        return "SIDE"

# ====================== Plot ======================

def plot_chart(df, levels, symbol, out_dir="sr_charts", tf="5m", right_offset=50, dpi=160):
    ensure_dir(out_dir)
    fig, ax = plt.subplots(figsize=(12,5), dpi=dpi)
    x=np.arange(len(df)); ax.plot(x, df["close"].values, color="#dddddd", lw=0.9)

    for lv in levels:
        i=lv["index"]; y=lv["price"]; side=lv["side"]
        line_color = "orange" if side=="RES" else "cyan"
        ax.hlines(y, 0, len(df)+right_offset, colors=line_color, linestyles="--", lw=1.3, alpha=0.9)
        ax.text(len(df)+1, y, f"{y:.6f}", va="center", fontsize=8, color=line_color)
        if i+2 < len(df):
            if side=="SUP":
                ax.plot([i+1, i+2], df["close"].iloc[i+1:i+3], color="limegreen", lw=2.2)
            else:
                ax.plot([i+1, i+2], df["close"].iloc[i+1:i+3], color="red", lw=2.2)

    ax.set_title(f"{symbol} ‚Äî 0.70% + 1T kapalƒ± + 2T CANLI [{tf}]")
    ax.grid(True, alpha=0.25)
    fig.tight_layout()
    path=os.path.join(out_dir,f"{symbol.replace('/','_')}_{tf}.png")
    fig.savefig(path); plt.close(fig)
    return path

# ====================== Worker ======================

class ScannerWorker(threading.Thread):
    def __init__(self, window: sg.Window, settings: dict):
        super().__init__(daemon=True)
        self.window=window; self.settings=settings
        self.stop_event=threading.Event()
        self.ex=load_exchange()

    def request_stop(self): self.stop_event.set()

    def _fetch_df(self, s):
        return to_df(fetch_ohlcv_with_retry(self.ex, s, self.settings["tf"], self.settings["limit"]))

    def scan_all_coins(self):
        tf=self.settings["tf"]; uni=self.settings["universe"]
        sp=self.settings["swing_period"]; ttl_h=self.settings["ttl_h"]; tol=self.settings["tol_pct"]
        save=self.settings["save_charts"]; out=self.settings["out_dir"]

        vol_h=self.settings["vol_hours"]; corr_h=self.settings["corr_hours"]
        vol_min=self.settings["vol_min"]; corr_abs_max=self.settings["corr_abs_max"]

        trend_mode=self.settings["trend_mode"]  # "5h_struct" or "24h_change"

        btc_df = get_btc_df_cached(self.ex, tf, self.settings["limit"], drop_last=True, source="perp")
        vol_bars = bar_count_from_hours(tf, vol_h)
        corr_bars = bar_count_from_hours(tf, corr_h)

        syms = list_usdtm_symbols(self.ex, topN=uni)
        self.window.write_event_value("LOG", f"üîç {len(syms)} coin taranƒ±yor...")

        scanned=0; found=0
        for s in syms:
            if self.stop_event.is_set(): return
            try:
                scanned += 1
                df = self._fetch_df(s)

                # --- Vol & Corr filtreleri ---
                vol_score = compute_vol_score(df, vol_bars)
                corr_val  = compute_corr_with_btc(df, btc_df, corr_bars)
                if vol_score < vol_min:             # Vol ‚â•
                    continue
                if abs(corr_val) > corr_abs_max:    # |Corr| ‚â§
                    continue

                # --- Trend (HTF gate) ---
                if trend_mode == "5h_struct":
                    df1h = to_df(fetch_ohlcv_with_retry(self.ex, s, "1h", 60))
                    trend_val = htf_trend_struct(df1h, lookback_hours=5, left=1, right=1, min_swing_pct=0.001)
                else:
                    trend_val = trend_from_24h(self.ex, s)

                if trend_val == "UP":
                    allowed_sides = {"SUP"}
                elif trend_val == "DOWN":
                    allowed_sides = {"RES"}
                else:
                    allowed_sides = {"SUP","RES"}  # SIDE

                # --- Sinyal (yalnƒ±zca 2. bar CANLI) ---
                levels = detect_levels_minimal(df, tf=tf, swing_period=sp, tol_pct=tol, ttl_h=ttl_h)
                if not levels:
                    continue

                # SUP/RES ‚Äî trend filtresine g√∂re ge√ßir
                for side in ["SUP","RES"]:
                    if side not in allowed_sides:
                        continue
                    cand=[lv for lv in levels if lv["side"]==side]
                    if not cand:
                        continue
                    use_lv=cand[-1]
                    chart = plot_chart(df.reset_index(), [use_lv], s, out, tf) if save else ""

                    row=[s, side, f"{use_lv['price']:.6f}",
                         f"{vol_score:.2f}", f"{corr_val:+.2f}", trend_val, chart]
                    self.window.write_event_value("SCAN_ROW", row)
                    found += 1

                    if self.settings["telegram"]:
                        send_telegram_alert(
                            f"üîî {s} | {side} {use_lv['price']:.6f}\n"
                            f"Vol={vol_score:.2f}  Corr={corr_val:+.2f}  Trend(HTF-5h)={trend_val}"
                        )

            except Exception as e:
                self.window.write_event_value("LOG", f"{s}: {e}")

            if scanned % 50 == 0:
                self.window.write_event_value("LOG", f"üìä {scanned}/{len(syms)} tarandƒ± | {found} listede")

        self.window.write_event_value("LOG", f"‚úÖ Tamamlandƒ±. {scanned} tarandƒ± | {found} listede")

    def run(self):
        self.window.write_event_value("LOG","üöÄ Tarama ba≈üladƒ±...")
        interval = self.settings["interval_s"]
        while not self.stop_event.is_set():
            t0 = time.time()
            try:
                self.scan_all_coins()
            except Exception as e:
                self.window.write_event_value("LOG", f"‚ùå Hata: {e}")
            sleep_left = max(0.0, interval - (time.time() - t0))
            for _ in range(int(sleep_left*10)):
                if self.stop_event.is_set(): break
                time.sleep(0.1)
        self.window.write_event_value("LOG","‚è∏Ô∏è Tarama durduruldu.")

# ====================== GUI ======================

def make_window():
    sg.theme("DarkGrey13")
    left=[
        [sg.Text("Universe"), sg.Input("500", key="-UNIV-", size=(6,1)),
         sg.Text("TF"), sg.Combo(["5m","15m"], "5m", key="-TF-", readonly=True, size=(6,1)),
         sg.Text("Limit"), sg.Input("900", key="-LIM-", size=(6,1))],
        [sg.Text("Swing"), sg.Input("20", key="-SWING-", size=(6,1)),
         sg.Text("TTL(h)"), sg.Input("6", key="-TTL-", size=(6,1)),
         sg.Text("Cluster tol %"), sg.Input("0.5", key="-TOL-", size=(7,1))],
        [sg.Text("Vol ‚â•"), sg.Input("0.50", key="-VOL-", size=(6,1)),
         sg.Text("|Corr| ‚â§"), sg.Input("0.70", key="-CORR-", size=(6,1)),
         sg.Text("Trend Mode"),
         sg.Combo(["5h Structure (HH/HL)", "24h Change %"],
                  default_value="5h Structure (HH/HL)", key="-TMODE-", readonly=True, size=(20,1))],
        [sg.Checkbox("Save charts", key="-SAVE-", default=True),
         sg.Checkbox("Telegram", key="-TG-", default=False)],
        [sg.Button("START SCAN (20s loop)", key="-START-", size=(22,2),
                   button_color=("white","#1e7e34"), font=("Arial", 12, "bold"))],
        [sg.Button("STOP", key="-STOP-", size=(22,1),
                   button_color=("white","#8a1c1c"), font=("Arial", 10))]
    ]
    right=[
        [sg.Table(values=[],
                  headings=["Symbol","Side","Price","Vol","Corr","Trend(HTF)","Chart"],
                  key="-RES-", num_rows=24, expand_x=True, expand_y=True,
                  enable_events=True, auto_size_columns=True)],
        [sg.Button("Open Chart (selected)", key="-OPEN-")],
        [sg.Multiline(size=(100,8), key="-LOG-", autoscroll=True, disabled=True)]
    ]
    layout=[[sg.Column(left, vertical_alignment="top"),
             sg.VSeparator(),
             sg.Column(right, expand_x=True, expand_y=True)]]
    return sg.Window("META", layout, finalize=True, resizable=True)

def read_settings(v):
    tmode = _get(v, "-TMODE-", "5h Structure (HH/HL)")
    trend_mode = "5h_struct" if "5h" in tmode else "24h_change"
    return dict(
        tf=_get(v, "-TF-", "5m"),
        limit=_parse_int(v, "-LIM-", 900),
        universe=_parse_int(v, "-UNIV-", 500),
        swing_period=_parse_int(v, "-SWING-", 20),
        ttl_h=_parse_int(v, "-TTL-", 6),
        tol_pct=_parse_float(v, "-TOL-", 0.5),
        vol_hours=24,
        corr_hours=12,
        vol_min=_parse_float(v, "-VOL-", 0.50),
        corr_abs_max=_parse_float(v, "-CORR-", 0.70),
        save_charts=bool(_get(v, "-SAVE-", True)),
        telegram=bool(_get(v, "-TG-", False)),
        out_dir="sr_charts",
        interval_s=20,
        trend_mode=trend_mode,
    )

def main():
    win=make_window(); worker=None; rows=[]
    def log(msg): win["-LOG-"].update(value=win["-LOG-"].get()+msg+"\n")

    while True:
        e,v=win.read(timeout=100)
        if e in (sg.WIN_CLOSED,"Exit"):
            if worker: worker.request_stop()
            break

        if e=="-START-":
            if worker: worker.request_stop(); worker=None
            st=read_settings(v)
            worker=ScannerWorker(win,st)
            rows=[]; win["-RES-"].update(values=rows)
            worker.start()
            tlabel = "5h Structure (HH/HL)" if st["trend_mode"]=="5h_struct" else "24h Change %"
            log(f"üöÄ Ba≈üladƒ± ‚Äî 0.70% + 1T kapalƒ± + 2T CANLI. Filtre: Vol ‚â•, |Corr| ‚â§, Trend Mode: {tlabel}")

        elif e=="-STOP-":
            if worker: worker.request_stop(); worker=None
            log("‚è∏Ô∏è Durdu.")

        elif e=="-OPEN-":
            sel=v["-RES-"]
            if sel and rows:
                chart=rows[sel[0]][6]
                if chart and os.path.exists(chart): open_path(chart)

        elif e=="-SCAN_ROW":
            pass  # not used

        elif e=="SCAN_ROW":
            row=v[e]
            # aynƒ± sembol & side varsa g√ºncelle
            replaced=False
            for idx,r in enumerate(rows):
                if r[0]==row[0] and r[1]==row[1]:
                    rows[idx]=row; replaced=True; break
            if not replaced: rows.append(row)
            win["-RES-"].update(values=rows); win.refresh()

        elif e=="LOG":
            log(v[e])

    win.close()

if __name__ == "__main__":
    main()
# gold file
